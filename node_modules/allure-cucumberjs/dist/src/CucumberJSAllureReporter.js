"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CucumberJSAllureFormatter = exports.CucumberJSAllureFormatterConfig = exports.Allure = void 0;
const os_1 = __importDefault(require("os"));
const process_1 = __importDefault(require("process"));
const cucumber_1 = require("@cucumber/cucumber");
const messages = __importStar(require("@cucumber/messages"));
const messages_1 = require("@cucumber/messages");
const allure_js_commons_1 = require("allure-js-commons");
const CucumberAllureInterface_1 = require("./CucumberAllureInterface");
var allure_js_commons_2 = require("allure-js-commons");
Object.defineProperty(exports, "Allure", { enumerable: true, get: function () { return allure_js_commons_2.Allure; } });
class CucumberJSAllureFormatterConfig {
}
exports.CucumberJSAllureFormatterConfig = CucumberJSAllureFormatterConfig;
const { ALLURE_HOST_NAME, ALLURE_THREAD_NAME } = process_1.default.env;
class CucumberJSAllureFormatter extends cucumber_1.Formatter {
    constructor(options, allureRuntime, config) {
        super(options);
        this.allureRuntime = allureRuntime;
        this.currentAfter = null;
        this.currentBefore = null;
        this.currentGroup = null;
        this.currentTest = null;
        this.stepStack = [];
        this.hostname = ALLURE_HOST_NAME || os_1.default.hostname();
        this.documentMap = new Map();
        this.featureMap = new Map();
        this.scenarioMap = new Map();
        this.stepMap = new Map();
        this.testStepMap = new Map();
        this.pickleStepMap = new Map();
        this.stepDefinitionMap = new Map();
        this.testCaseTestStepsResults = new Map();
        this.pickleMap = new Map();
        this.hookMap = new Map();
        this.sourceMap = new Map();
        this.testCaseMap = new Map();
        this.testCaseStartedMap = new Map();
        this.allureSteps = new Map();
        this.runningTestsMap = new Map();
        this.convertStatus = (status) => {
            switch (status) {
                case messages_1.TestStepResultStatus.FAILED:
                    return allure_js_commons_1.Status.FAILED;
                case messages_1.TestStepResultStatus.PASSED:
                    return allure_js_commons_1.Status.PASSED;
                case messages_1.TestStepResultStatus.SKIPPED:
                case messages_1.TestStepResultStatus.PENDING:
                    return allure_js_commons_1.Status.SKIPPED;
                default:
                    return undefined;
            }
        };
        options.eventBroadcaster.on("envelope", this.parseEnvelope.bind(this));
        this.labelsMathers = config.labels || [];
        this.linksMatchers = config.links || [];
        this.exceptionFormatter = (message) => {
            if (config.exceptionFormatter !== undefined) {
                try {
                    return config.exceptionFormatter(message);
                }
                catch (e) {
                    console.warn(`Error in exceptionFormatter: ${e}`);
                }
            }
            return message;
        };
        this.allureInterface = new CucumberAllureInterface_1.CucumberAllureInterface(this, this.allureRuntime);
        options.supportCodeLibrary.World.prototype.allure = this.allureInterface;
        this.beforeHooks = options.supportCodeLibrary.beforeTestCaseHookDefinitions;
        this.afterHooks = options.supportCodeLibrary.afterTestCaseHookDefinitions;
    }
    get tagsIgnorePatterns() {
        const { linksMatchers, labelsMathers } = this;
        return [...linksMatchers, ...labelsMathers].flatMap(({ pattern }) => pattern);
    }
    parseEnvelope(envelope) {
        if (envelope.gherkinDocument) {
            this.onGherkinDocument(envelope.gherkinDocument);
        }
        else if (envelope.pickle) {
            this.onPickle(envelope.pickle);
        }
        else if (envelope.testCase) {
            this.onTestCase(envelope.testCase);
        }
        else if (envelope.testCaseStarted) {
            this.onTestCaseStarted(envelope.testCaseStarted);
        }
        else if (envelope.testCaseFinished) {
            this.onTestCaseFinished(envelope.testCaseFinished);
        }
        else if (envelope.attachment) {
            this.onAttachment(envelope.attachment);
        }
        else if (envelope.hook) {
            this.onHook(envelope.hook);
        }
        else if (envelope.source) {
            this.onSource(envelope.source);
        }
        else if (envelope.testStepStarted) {
            this.onTestStepStarted(envelope.testStepStarted);
        }
        else if (envelope.testStepFinished) {
            this.onTestStepFinished(envelope.testStepFinished);
        }
    }
    parseTagsLabels(tags) {
        const labels = [];
        if (this.labelsMathers.length === 0) {
            return labels;
        }
        this.labelsMathers.forEach((matcher) => {
            const matchedTags = tags.filter((tag) => matcher.pattern.some((pattern) => pattern.test(tag.name)));
            const matchedLabels = matchedTags.map((tag) => {
                const tagValue = tag.name.replace(/^@\S+:/, "");
                return {
                    name: matcher.name,
                    value: tagValue,
                };
            });
            labels.push(...matchedLabels);
        });
        return labels;
    }
    parseTagsLinks(tags) {
        const tagKeyRe = /^@\S+=/;
        const links = [];
        if (this.linksMatchers.length === 0) {
            return links;
        }
        this.linksMatchers.forEach((matcher) => {
            const matchedTags = tags.filter((tag) => matcher.pattern.some((pattern) => pattern.test(tag.name)));
            const matchedLinks = matchedTags.map((tag) => {
                const tagValue = tag.name.replace(tagKeyRe, "");
                return {
                    url: matcher.urlTemplate.replace(/%s$/, tagValue) || tagValue,
                    type: matcher.type,
                };
            });
            links.push(...matchedLinks);
        });
        return links;
    }
    onGherkinDocument(data) {
        var _a, _b;
        if (data.uri) {
            this.documentMap.set(data.uri, data);
        }
        (_b = (_a = data.feature) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.forEach((fc) => {
            if (fc.scenario) {
                this.onScenario(fc.scenario);
            }
        });
    }
    onScenario(data) {
        this.scenarioMap.set(data.id, data);
        data.steps.forEach((step) => this.stepMap.set(step.id, step));
    }
    onPickle(data) {
        this.pickleMap.set(data.id, data);
        data.steps.forEach((ps) => this.pickleStepMap.set(ps.id, ps));
    }
    onTestCase(data) {
        this.testCaseMap.set(data.id, data);
        data.testSteps.forEach((ts) => this.testStepMap.set(ts.id, ts));
    }
    onTestCaseStarted(data) {
        var _a, _b;
        const testCase = this.testCaseMap.get(data.testCaseId);
        if (!testCase) {
            console.error("onTestCaseStarted", "test case not found", data);
            return;
        }
        const pickle = this.pickleMap.get(testCase.pickleId);
        if (!pickle) {
            console.error("onTestCaseStarted", "pickle not found", data);
            return;
        }
        const doc = this.documentMap.get(pickle.uri);
        const scenarioId = (_a = pickle === null || pickle === void 0 ? void 0 : pickle.astNodeIds) === null || _a === void 0 ? void 0 : _a[0];
        const scenario = this.scenarioMap.get(scenarioId);
        const labels = this.parseTagsLabels((scenario === null || scenario === void 0 ? void 0 : scenario.tags) || []);
        const links = this.parseTagsLinks((scenario === null || scenario === void 0 ? void 0 : scenario.tags) || []);
        const currentTest = new allure_js_commons_1.AllureTest(this.allureRuntime, Date.now());
        this.runningTestsMap.set(data.id, currentTest);
        this.testCaseStartedMap.set(data.id, data);
        this.testCaseTestStepsResults.set(data.id, []);
        currentTest.name = pickle.name;
        currentTest === null || currentTest === void 0 ? void 0 : currentTest.addLabel(allure_js_commons_1.LabelName.HOST, this.hostname);
        currentTest === null || currentTest === void 0 ? void 0 : currentTest.addLabel(allure_js_commons_1.LabelName.THREAD, ALLURE_THREAD_NAME || process_1.default.getuid().toString());
        currentTest === null || currentTest === void 0 ? void 0 : currentTest.addLabel(allure_js_commons_1.LabelName.LANGUAGE, "javascript");
        currentTest === null || currentTest === void 0 ? void 0 : currentTest.addLabel(allure_js_commons_1.LabelName.FRAMEWORK, "cucumberjs");
        if (doc === null || doc === void 0 ? void 0 : doc.feature) {
            currentTest.addLabel(allure_js_commons_1.LabelName.FEATURE, doc.feature.name);
        }
        if (scenario) {
            currentTest === null || currentTest === void 0 ? void 0 : currentTest.addLabel(allure_js_commons_1.LabelName.SUITE, scenario.name);
        }
        if (labels.length > 0) {
            labels.forEach((label) => currentTest === null || currentTest === void 0 ? void 0 : currentTest.addLabel(label.name, label.value));
        }
        if ((_b = pickle.tags) === null || _b === void 0 ? void 0 : _b.length) {
            const filteredTags = pickle.tags.filter((tag) => !this.tagsIgnorePatterns.some((pattern) => pattern.test(tag.name)));
            filteredTags.forEach((tag) => {
                currentTest === null || currentTest === void 0 ? void 0 : currentTest.addLabel(allure_js_commons_1.LabelName.TAG, tag.name);
            });
        }
        links.forEach((link) => currentTest === null || currentTest === void 0 ? void 0 : currentTest.addLink(link.url, link.name, link.type));
        pickle.steps.forEach((ps) => {
            const { argument } = ps;
            if (!currentTest || !(argument === null || argument === void 0 ? void 0 : argument.dataTable)) {
                return;
            }
            const csvDataTable = argument.dataTable.rows.reduce((acc, row) => `${acc + row.cells.map((cell) => cell.value).join(",")}\n`, "");
            const attachmentFilename = this.allureRuntime.writeAttachment(csvDataTable, "text/csv");
            currentTest.addAttachment("Data table", {
                contentType: "text/csv",
            }, attachmentFilename);
        });
        if (!scenario) {
            return;
        }
        if (scenario.examples.length === 0) {
            return;
        }
        scenario.examples.forEach((example) => {
            var _a;
            if (!currentTest) {
                return;
            }
            const csvDataTableHeader = ((_a = example === null || example === void 0 ? void 0 : example.tableHeader) === null || _a === void 0 ? void 0 : _a.cells.map((cell) => cell.value).join(",")) || "";
            const csvDataTableBody = (example === null || example === void 0 ? void 0 : example.tableBody.map((row) => row.cells.map((cell) => cell.value).join(",")).join("\n")) ||
                "";
            if (!csvDataTableHeader && !csvDataTableBody) {
                return;
            }
            const csvDataTable = `${csvDataTableHeader}\n${csvDataTableBody}\n`;
            const attachmentFilename = this.allureRuntime.writeAttachment(csvDataTable, "text/csv");
            currentTest.addAttachment("Examples", {
                contentType: "text/csv",
            }, attachmentFilename);
        });
    }
    onAttachment(data) {
        const currentTest = this.runningTestsMap.get((data === null || data === void 0 ? void 0 : data.testCaseStartedId) || "");
        if (!currentTest) {
            return;
        }
        if (!data) {
            console.error("onAttachment", "attachment can't be empty");
            return;
        }
        const { fileName = "attachment", body, mediaType, contentEncoding } = data;
        const encoding = Buffer.isEncoding(contentEncoding) ? contentEncoding : undefined;
        const attachmentFilename = this.allureRuntime.writeAttachment(body, mediaType, encoding);
        currentTest.addAttachment(fileName, {
            contentType: mediaType,
        }, attachmentFilename);
    }
    onTestCaseFinished(data) {
        const currentTest = this.runningTestsMap.get(data.testCaseStartedId);
        if (!currentTest) {
            console.error("onTestCaseFinished", "current test not found", data);
            return;
        }
        const testCaseStarted = this.testCaseStartedMap.get(data.testCaseStartedId);
        if (!testCaseStarted) {
            console.error("onTestCaseFinished", "testCaseStarted event not found", data);
            return;
        }
        const testCase = this.testCaseMap.get(testCaseStarted.testCaseId);
        if (!testCase) {
            console.error("onTestCaseFinished", "testCase not found", data);
            return;
        }
        const pickle = this.pickleMap.get(testCase.pickleId);
        if (!pickle) {
            console.error("onTestCaseFinished", "pickle not found", data);
            return;
        }
        const testStepResults = this.testCaseTestStepsResults.get(testCaseStarted.id);
        if (testStepResults === null || testStepResults === void 0 ? void 0 : testStepResults.length) {
            const worstTestStepResult = messages.getWorstTestStepResult(testStepResults);
            currentTest.status = this.convertStatus(worstTestStepResult.status);
            currentTest.statusDetails = {
                message: worstTestStepResult.message,
            };
        }
        else {
            currentTest.status = allure_js_commons_1.Status.PASSED;
        }
        currentTest.endTest(Date.now());
        this.runningTestsMap.delete(data.testCaseStartedId);
    }
    onHook(data) {
        this.hookMap.set(data.id, data);
    }
    onSource(data) {
        if (data.uri) {
            this.sourceMap.set(data.uri, data);
        }
    }
    onTestStepStarted(data) {
        const currentTest = this.runningTestsMap.get(data.testCaseStartedId);
        if (!currentTest) {
            return;
        }
        const testStep = this.testStepMap.get(data.testStepId);
        if (!testStep) {
            console.error("onTestStepStarted", "can't find step", data);
            return;
        }
        if (testStep.pickleStepId) {
            const ps = this.pickleStepMap.get(testStep.pickleStepId);
            if (!ps) {
                return;
            }
            const keyword = ps.astNodeIds
                .map((astNodeId) => this.stepMap.get(astNodeId))
                .map((step) => step === null || step === void 0 ? void 0 : step.keyword)
                .find((kw) => kw !== undefined) || "";
            const allureStep = currentTest.startStep(keyword + ps.text, Date.now());
            this.allureSteps.set(data.testStepId, allureStep);
        }
    }
    onTestStepFinished(data) {
        var _a;
        const currentTest = this.runningTestsMap.get(data.testCaseStartedId);
        (_a = this.testCaseTestStepsResults.get(data.testCaseStartedId)) === null || _a === void 0 ? void 0 : _a.push(data.testStepResult);
        if (!currentTest) {
            return;
        }
        const allureStep = this.allureSteps.get(data.testStepId);
        if (!allureStep) {
            return;
        }
        allureStep.detailsMessage = data.testStepResult.message;
        allureStep.status = this.convertStatus(data.testStepResult.status);
        allureStep.endStep(Date.now());
    }
}
exports.CucumberJSAllureFormatter = CucumberJSAllureFormatter;
//# sourceMappingURL=CucumberJSAllureReporter.js.map